隐式类型转换：
c的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换成为整型提升
如	char a,b,c;
	...
	a = b + c;
b,c的值被提升为普通整型，然后再执行加法运算
加法运算完成之后，结果将被截断(变回字符类型,挑最低位字节截断)，然后再存储于a中

为何整形提升？
方便计算机计算,CPU的通用寄存器长度一般是int类型的长度，两个8bit字节相加运算很难直接实现，因此任何可能小于int类型长度的整型值都要先转换为int或者unsigned int，然后才能送到CPU去执行运算(超简略介绍啊...);

如何整形提升？
整形提升时要看被提升对象是否为有符号数
1.对整形有符号数而言：
整形提升是按照变量的数据类型的符号位来提升的
负数整形提升时用 1  ，正数整形提升时用 0

2.对整形无符号数而言：
提升时默认用 0
如	char a = 3;  // 00000011
	char b = 127;// 01111111
	char c = a + b;
	//a提升 00000000000000000000000000000011
	//b提升 00000000000000000000000001111111
	//相加得00000000000000000000000011111110
	//c截断 11111110
	// 符号位是1，表示负数，由原反补规则可得
	// c = -126
	printf("%d\n", c);
	// 此时要打印一个整形，c要整形提升
	//c提升 11111111111111111111111111111110

经典题目：
1.
	char a = 0xb6;
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)
		printf("a"); 
	if (b == 0xb600)
		printf("b");
	if (c == 0xb6000000)
		printf("c");
// a - 10110110
// b - 1011011000000000
// c - 10110110000000000000000000000000
// a,b类型大小小于整形，整形提升后补符号位不等于原来的值
// c是整形，不需要整形提升，等于原值
// 所以只打印 c

2.
	char c = 1;
	printf("%u\n", sizeof(c));
	printf("%u\n", sizeof(+c));
	printf("%u\n", sizeof(!c));
// 结果 1 4 1
// +/-等是算术运算，会整形提升
// ! 是逻辑反操作，不是算术操作